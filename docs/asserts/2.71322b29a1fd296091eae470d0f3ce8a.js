webpackJsonp(2,{30:function(a,b,c){var d={"./active.js":101,"./ajax.js":102,"./animation.js":103,"./circular.js":104,"./core.js":105,"./demo.js":106,"./hash.js":107,"./jqevents.js":108,"./keyboard.js":109,"./mobile.js":110,"./mouse.js":111,"./near.js":112,"./start.js":113,"./templates.js":114,"./transform.js":115,"./viewport.js":116,"./ways.js":117},e=a.exports=function(a){return c(d[a+""]||d[a+".webpack.js"]||d[a+".web.js"]||d[a+".js"]||a)};e.keys=function(){return Object.keys(d)}},31:function(a,b,c){var d={"./duration.js":118,"./presentation-mode.js":119,"./secondary.js":120,"./toggle.js":121},e=a.exports=function(a){return c(d[a+""]||d[a+".webpack.js"]||d[a+".web.js"]||d[a+".js"]||a)};e.keys=function(){return Object.keys(d)}},32:function(a,b,c){function d(a){if(a===null||typeof a=="undefined")return"";var b=a+"",c="",d,e,f=0;d=e=0,f=b.length;for(var g=0;g<f;g++){var h=b.charCodeAt(g),i=null;h<128?e++:h>127&&h<2048?i=String.fromCharCode(h>>6|192)+String.fromCharCode(h&63|128):i=String.fromCharCode(h>>12|224)+String.fromCharCode(h>>6&63|128)+String.fromCharCode(h&63|128),i!==null&&(e>d&&(c+=b.slice(d,e)),c+=i,d=e=g+1)}return e>d&&(c+=b.slice(d,f)),c}function e(a){var b="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",c,e,f,g,h,i,j,k,l=0,m=0,n="",o=[];if(!a)return a;a=d(a+"");do c=a.charCodeAt(l++),e=a.charCodeAt(l++),f=a.charCodeAt(l++),k=c<<16|e<<8|f,g=k>>18&63,h=k>>12&63,i=k>>6&63,j=k&63,o[m++]=b.charAt(g)+b.charAt(h)+b.charAt(i)+b.charAt(j);while(l<a.length);n=o.join("");var p=a.length%3;return(p?n.slice(0,p-3):n)+"===".slice(p||3)}a.exports=e},33:function(a,b,c){function e(a){return c(30)("./"+a+".js")}function f(a){return c(31)("./"+a+".js")}function g(a){function c(a){b[a.name]=!0,a.dependencies&&a.dependencies.forEach(c)}var b={};d.components.forEach(function(b){a[b.name]&&c(b)});var g=[e("core"),e("near")];return d.components.forEach(function(a){b[a.name]&&g.push(a.plugin?f(a.name):e(a.name))}),g.join("\n")}var d=c(28);a.exports=g},101:function(a,b,c){a.exports="/*!\n * active.js\n * Set the active classes on steps\n */\n(function( $, document, window, undefined ) {\n\n	'use strict';\n	var $jmpress = $.jmpress;\n\n	/* DEFINES */\n	var activeClass = 'activeClass',\n		nestedActiveClass = 'nestedActiveClass';\n\n	/* DEFAULTS */\n	var defaults = $jmpress( 'defaults' );\n	defaults[nestedActiveClass] = \"nested-active\";\n	defaults[activeClass]       = \"active\";\n\n	/* HOOKS */\n	$jmpress( 'setInactive', function( step, eventData ) {\n		var settings = eventData.settings,\n			activeClassSetting = settings[activeClass],\n			nestedActiveClassSettings = settings[nestedActiveClass];\n		if(activeClassSetting) {\n			$(step).removeClass( activeClassSetting );\n		}\n		if(nestedActiveClassSettings) {\n			$.each(eventData.parents, function(idx, element) {\n				$(element).removeClass(nestedActiveClassSettings);\n			});\n		}\n	});\n	$jmpress( 'setActive', function( step, eventData ) {\n		var settings = eventData.settings,\n			activeClassSetting = settings[activeClass],\n			nestedActiveClassSettings = settings[nestedActiveClass];\n		if(activeClassSetting) {\n			$(step).addClass( activeClassSetting );\n		}\n		if(nestedActiveClassSettings) {\n			$.each(eventData.parents, function(idx, element) {\n				$(element).addClass(nestedActiveClassSettings);\n			});\n		}\n	});\n\n}(jQuery, document, window));"},102:function(a,b,c){a.exports="/*!\n * ajax.js\n * Load steps via ajax\n */\n(function( $, document, window, undefined ) {\n\n	'use strict';\n	var $jmpress = $.jmpress;\n\n	/* DEFINES */\n	var afterStepLoaded = 'ajax:afterStepLoaded',\n		loadStep = 'ajax:loadStep';\n\n	/* REGISTER EVENTS */\n	$jmpress('register', loadStep);\n	$jmpress('register', afterStepLoaded);\n\n	/* DEFAULTS */\n	$jmpress('defaults').ajaxLoadedClass = \"loaded\";\n\n	/* HOOKS */\n	$jmpress('initStep', function( step, eventData ) {\n		eventData.stepData.src = $(step).attr('href') || eventData.data.src || false;\n		eventData.stepData.srcLoaded = false;\n	});\n	$jmpress(loadStep, function( step, eventData ) {\n		var stepData = eventData.stepData,\n			href = stepData && stepData.src,\n			settings = eventData.settings;\n		if ( href ) {\n			$(step).addClass( settings.ajaxLoadedClass );\n			stepData.srcLoaded = true;\n			$(step).load(href, function(response, status, xhr) {\n				$(eventData.jmpress).jmpress('fire', afterStepLoaded, step, $.extend({}, eventData, {\n					response: response\n					,status: status\n					,xhr: xhr\n				}));\n			});\n		}\n	});\n	$jmpress('idle', function( step, eventData ) {\n		if (!step) {\n			return;\n		}\n		var settings = eventData.settings,\n			jmpress = $(this),\n			stepData = eventData.stepData;\n		var siblings = $(step)\n			.add( $(step).near( settings.stepSelector ) )\n			.add( $(step).near( settings.stepSelector, true) )\n			.add( jmpress.jmpress('fire', 'selectPrev', step, {\n				stepData: $(step).data('stepData')\n			}))\n			.add( jmpress.jmpress('fire', 'selectNext', step, {\n				stepData: $(step).data('stepData')\n			}));\n		siblings.each(function() {\n			var step = this,\n				stepData = $(step).data(\"stepData\");\n			if(!stepData.src || stepData.srcLoaded) {\n				return;\n			}\n			jmpress.jmpress('fire', loadStep, step, {\n				stepData: $(step).data('stepData')\n			});\n		});\n	});\n	$jmpress(\"setActive\", function(step, eventData) {\n		var stepData = $(step).data(\"stepData\");\n		if(!stepData.src || stepData.srcLoaded) {\n			return;\n		}\n		$(this).jmpress('fire', loadStep, step, {\n			stepData: $(step).data('stepData')\n		});\n	});\n\n}(jQuery, document, window));"},103:function(a,b,c){a.exports='/*!\n * animation.js\n * Apply custom animations to steps\n */\n(function( $, document, window, undefined ) {\n\n	\'use strict\';\n\n	function randomString() {\n		return "" + Math.round(Math.random() * 100000, 0);\n	}\n\n	function parseSubstepInfo(str) {\n		var arr = str.split(" ");\n		var className = arr[0];\n		var config = { willClass: "will-"+className, doClass: "do-"+className, hasClass: "has-"+className };\n		var state = "";\n		for(var i = 1; i < arr.length; i++) {\n			var s = arr[i];\n			switch(state) {\n			case "":\n				if(s === "after") {\n					state = "after";\n				} else {\n					$.warn("unknown keyword in \'"+str+"\'. \'"+s+"\' unknown.");\n				}\n				break;\n			case "after":\n				if(s.match(/^[1-9][0-9]*m?s?/)) {\n					var value = parseFloat(s);\n					if(s.indexOf("ms") !== -1) {\n						value *= 1;\n					} else if(s.indexOf("s") !== -1) {\n						value *= 1000;\n					} else if(s.indexOf("m") !== -1) {\n						value *= 60000;\n					}\n					config.delay = value;\n				} else {\n					config.after = Array.prototype.slice.call(arr, i).join(" ");\n				}\n			}\n		}\n		return config;\n	}\n	function find(array, selector, start, end) {\n		end = end || (array.length - 1);\n		start = start || 0;\n		for(var i = start; i < end + 1; i++) {\n			if($(array[i].element).is(selector)) {\n				return i;\n			}\n		}\n	}\n	function addOn(list, substep, delay) {\n		$.each(substep._on, function(idx, child) {\n			list.push({substep: child.substep, delay: child.delay + delay});\n			addOn(list, child.substep, child.delay + delay);\n		});\n	}\n	$.jmpress("defaults").customAnimationDataAttribute = "jmpress";\n	$.jmpress("afterInit", function( nil, eventData ) {\n		eventData.current.animationTimeouts = [];\n		eventData.current.animationCleanupWaiting = [];\n	});\n	$.jmpress("applyStep", function( step, eventData ) {\n		// read custom animation from elements\n		var substepsData = {};\n		var listOfSubsteps = [];\n		$(step).find("[data-"+eventData.settings.customAnimationDataAttribute+"]")\n				.each(function(idx, element) {\n			if($(element).closest(eventData.settings.stepSelector).is(step)) {\n				listOfSubsteps.push({element: element});\n			}\n		});\n		if(listOfSubsteps.length === 0) {\n			return;\n		}\n		$.each(listOfSubsteps, function(idx, substep) {\n			substep.info = parseSubstepInfo(\n				$(substep.element).data(eventData.settings.customAnimationDataAttribute));\n			$(substep.element).addClass(substep.info.willClass);\n			substep._on = [];\n			substep._after = null;\n		});\n		var current = {_after: undefined, _on: [], info: {}}; // virtual zero step\n		$.each(listOfSubsteps, function(idx, substep) {\n			var other = substep.info.after;\n			if(other) {\n				if(other === "step") {\n					other = current;\n				} else if(other === "prev") {\n					other = listOfSubsteps[idx-1];\n				} else {\n					var index = find(listOfSubsteps, other, 0, idx - 1);\n					if(index === -1) {\n						index = find(listOfSubsteps, other);\n					}\n					other = (index === -1 || index === idx) ? listOfSubsteps[idx-1] : listOfSubsteps[index];\n				}\n			} else {\n				other = listOfSubsteps[idx-1];\n			}\n			if(other) {\n				if(!substep.info.delay) {\n					if(!other._after) {\n						other._after = substep;\n						return;\n					}\n					other = other._after;\n				}\n				other._on.push({substep: substep, delay: substep.info.delay || 0});\n			}\n		});\n		if(current._after === undefined && current._on.length === 0) {\n			var startStep = find(listOfSubsteps, eventData.stepData.startSubstep) || 0;\n			current._after = listOfSubsteps[startStep];\n		}\n		var substepsInOrder = [];\n		function findNextFunc(idx, item) {\n			if(item.substep._after) {\n				current = item.substep._after;\n				return false;\n			}\n		}\n		do {\n			var substepList = [{substep: current, delay: 0}];\n			addOn(substepList, current, 0);\n			substepsInOrder.push(substepList);\n			current = null;\n			$.each(substepList, findNextFunc);\n		} while(current);\n		substepsData.list = substepsInOrder;\n		$(step).data("substepsData", substepsData);\n	});\n	$.jmpress("unapplyStep", function( step, eventData ) {\n		var substepsData = $(step).data("substepsData");\n		if(substepsData) {\n			$.each(substepsData.list, function(idx, activeSubsteps) {\n				$.each(activeSubsteps, function(idx, substep) {\n					if(substep.substep.info.willClass) {\n						$(substep.substep.element).removeClass(substep.substep.info.willClass);\n					}\n					if(substep.substep.info.hasClass) {\n						$(substep.substep.element).removeClass(substep.substep.info.hasClass);\n					}\n					if(substep.substep.info.doClass) {\n						$(substep.substep.element).removeClass(substep.substep.info.doClass);\n					}\n				});\n			});\n		}\n	});\n	$.jmpress("setActive", function(step, eventData) {\n		var substepsData = $(step).data("substepsData");\n		if(!substepsData) {\n			return;\n		}\n		if(eventData.substep === undefined) {\n			eventData.substep =\n				(eventData.reason === "prev" ?\n					substepsData.list.length-1 :\n					0\n				);\n		}\n		var substep = eventData.substep;\n		$.each(eventData.current.animationTimeouts, function(idx, timeout) {\n			clearTimeout(timeout);\n		});\n		eventData.current.animationTimeouts = [];\n		$.each(substepsData.list, function(idx, activeSubsteps) {\n			var applyHas = idx < substep;\n			var applyDo = idx <= substep;\n			$.each(activeSubsteps, function(idx, substep) {\n				if(substep.substep.info.hasClass) {\n					$(substep.substep.element)[(applyHas?"add":"remove")+"Class"](substep.substep.info.hasClass);\n				}\n				function applyIt() {\n					$(substep.substep.element).addClass(substep.substep.info.doClass);\n				}\n				if(applyDo && !applyHas && substep.delay && eventData.reason !== "prev") {\n					if(substep.substep.info.doClass) {\n						$(substep.substep.element).removeClass(substep.substep.info.doClass);\n						eventData.current.animationTimeouts.push(setTimeout(applyIt, substep.delay));\n					}\n				} else {\n					if(substep.substep.info.doClass) {\n						$(substep.substep.element)[(applyDo?"add":"remove")+"Class"](substep.substep.info.doClass);\n					}\n				}\n			});\n		});\n	});\n	$.jmpress("setInactive", function(step, eventData) {\n		if(eventData.nextStep === step) {\n			return;\n		}\n		function cleanupAnimation( substepsData ) {\n			$.each(substepsData.list, function(idx, activeSubsteps) {\n				$.each(activeSubsteps, function(idx, substep) {\n					if(substep.substep.info.hasClass) {\n						$(substep.substep.element).removeClass(substep.substep.info.hasClass);\n					}\n					if(substep.substep.info.doClass) {\n						$(substep.substep.element).removeClass(substep.substep.info.doClass);\n					}\n				});\n			});\n		}\n		$.each(eventData.current.animationCleanupWaiting, function(idx, item) {\n			cleanupAnimation(item);\n		});\n		eventData.current.animationCleanupWaiting = [];\n		var substepsData = $(step).data("substepsData");\n		if(substepsData) {\n			eventData.current.animationCleanupWaiting.push( substepsData );\n		}\n	});\n	$.jmpress("selectNext", function( step, eventData ) {\n		if(eventData.substep === undefined) {\n			return;\n		}\n		var substepsData = $(step).data("substepsData");\n		if(!substepsData) {\n			return;\n		}\n		if(eventData.substep < substepsData.list.length-1) {\n			return {step: step, substep: eventData.substep+1};\n		}\n	});\n	$.jmpress("selectPrev", function( step, eventData ) {\n		if(eventData.substep === undefined) {\n			return;\n		}\n		var substepsData = $(step).data("substepsData");\n		if(!substepsData) {\n			return;\n		}\n		if(eventData.substep > 0) {\n			return {step: step, substep: eventData.substep-1};\n		}\n	});\n\n}(jQuery, document, window));'},104:function(a,b,c){a.exports="/*!\n * circular.js\n * Repeat from start after end\n */\n(function( $, document, window, undefined ) {\n\n	'use strict';\n	var $jmpress = $.jmpress;\n\n	/* FUNCTIONS */\n	function firstSlide( step, eventData ) {\n		return $(this).find(eventData.settings.stepSelector).first();\n	}\n	function prevOrNext( jmpress, step, eventData, prev) {\n		if (!step) {\n			return false;\n		}\n		var stepSelector = eventData.settings.stepSelector;\n		step = $(step);\n		do {\n			var item = step.near( stepSelector, prev );\n			if (item.length === 0 || item.closest(jmpress).length === 0) {\n				item = $(jmpress).find(stepSelector)[prev?\"last\":\"first\"]();\n			}\n			if (!item.length) {\n				return false;\n			}\n			step = item;\n		} while( step.data(\"stepData\").exclude );\n		return step;\n	}\n\n	/* HOOKS */\n	$jmpress( 'initStep', function( step, eventData ) {\n		eventData.stepData.exclude = eventData.data.exclude && [\"false\", \"no\"].indexOf(eventData.data.exclude) === -1;\n	});\n	$jmpress( 'selectInitialStep', firstSlide);\n	$jmpress( 'selectHome', firstSlide);\n	$jmpress( 'selectEnd', function( step, eventData ) {\n		return $(this).find(eventData.settings.stepSelector).last();\n	});\n	$jmpress( 'selectPrev', function( step, eventData ) {\n		return prevOrNext(this, step, eventData, true);\n	});\n	$jmpress( 'selectNext', function( step, eventData ) {\n		return prevOrNext(this, step, eventData);\n	});\n}(jQuery, document, window));"},105:function(a,b,c){a.exports="/*!\n * core.js\n * The core of jmpress.js\n */\n(function( $, document, window, undefined ) {\n\n	'use strict';\n\n	/**\n	 * Set supported prefixes\n	 *\n	 * @access protected\n	 * @return Function to get prefixed property\n	 */\n	var pfx = (function () {\n		var style = document.createElement('dummy').style,\n			prefixes = 'Webkit Moz O ms Khtml'.split(' '),\n			memory = {};\n		return function ( prop ) {\n			if ( typeof memory[ prop ] === \"undefined\" ) {\n				var ucProp  = prop.charAt(0).toUpperCase() + prop.substr(1),\n					props   = (prop + ' ' + prefixes.join(ucProp + ' ') + ucProp).split(' ');\n				memory[ prop ] = null;\n				for ( var i in props ) {\n					if ( style[ props[i] ] !== undefined ) {\n						memory[ prop ] = props[i];\n						break;\n					}\n				}\n			}\n			return memory[ prop ];\n		};\n	}());\n\n	/**\n	 * map ex. \"WebkitTransform\" to \"-webkit-transform\"\n	 */\n	function mapProperty( name ) {\n		if(!name) {\n			return;\n		}\n		var index = 1 + name.substr(1).search(/[A-Z]/);\n		var prefix = name.substr(0, index).toLowerCase();\n		var postfix = name.substr(index).toLowerCase();\n		return \"-\" + prefix + \"-\" + postfix;\n	}\n	function addComma( attribute ) {\n		if(!attribute) {\n			return \"\";\n		}\n		return attribute + \",\";\n	}\n\n	/**\n	 * Default Settings\n	 */\n	var defaults = {\n		/* CLASSES */\n		stepSelector: '.step'\n		,containerClass: ''\n		,canvasClass: ''\n		,areaClass: ''\n		,notSupportedClass: 'not-supported'\n\n		/* CONFIG */\n		,fullscreen: true\n\n		/* ANIMATION */\n		,animation: {\n			transformOrigin: 'top left'\n			,transitionProperty: addComma(mapProperty(pfx('transform'))) + addComma(mapProperty(pfx('perspective'))) + 'opacity'\n			,transitionDuration: '1s'\n			,transitionDelay: '500ms'\n			,transitionTimingFunction: 'ease-in-out'\n			,transformStyle: \"preserve-3d\"\n		}\n		,transitionDuration: 1500\n	};\n	var callbacks = {\n		'beforeChange': 1\n		,'beforeInitStep': 1\n		,'initStep': 1\n		,'beforeInit': 1\n		,'afterInit': 1\n		,'beforeDeinit': 1\n		,'afterDeinit': 1\n		,'applyStep': 1\n		,'unapplyStep': 1\n		,'setInactive': 1\n		,'beforeActive': 1\n		,'setActive': 1\n		,'selectInitialStep': 1\n		,'selectPrev': 1\n		,'selectNext': 1\n		,'selectHome': 1\n		,'selectEnd': 1\n		,'idle': 1\n		,'applyTarget': 1\n	};\n	for(var callbackName in callbacks) {\n		defaults[callbackName] = [];\n	}\n\n\n	/**\n	 * Initialize jmpress\n	 */\n	function init( args ) {\n		args = $.extend(true, {}, args || {});\n\n		// accept functions and arrays of functions as callbacks\n		var callbackArgs = {};\n		var callbackName = null;\n		for (callbackName in callbacks) {\n			callbackArgs[callbackName] = $.isFunction( args[callbackName] ) ?\n				[ args[callbackName] ] :\n				args[callbackName];\n			args[callbackName] = [];\n		}\n\n		// MERGE SETTINGS\n		var settings = $.extend(true, {}, defaults, args);\n\n		for (callbackName in callbacks) {\n			if (callbackArgs[callbackName]) {\n				Array.prototype.push.apply(settings[callbackName], callbackArgs[callbackName]);\n			}\n		}\n\n		/*** MEMBER VARS ***/\n\n		var jmpress = $( this )\n			,container = null\n			,area = null\n			,oldStyle = {\n				container: \"\"\n				,area: \"\"\n			}\n			,canvas = null\n			,current = null\n			,active = false\n			,activeSubstep = null\n			,activeDelegated = false;\n\n\n		/*** MEMBER FUNCTIONS ***/\n		// functions have to be called with this\n\n		/**\n		 * Init a single step\n		 *\n		 * @param element the element of the step\n		 * @param idx number of step\n		 */\n		function doStepInit( element, idx ) {\n			var data = dataset( element );\n			var step = {\n				oldStyle: $(element).attr(\"style\") || \"\"\n			};\n\n			var callbackData = {\n				data: data\n				,stepData: step\n			};\n			callCallback.call(this, 'beforeInitStep', $(element), callbackData);\n			step.delegate = data.delegate;\n			callCallback.call(this, 'initStep', $(element), callbackData);\n\n			$(element).data('stepData', step);\n\n			if ( !$(element).attr('id') ) {\n				$(element).attr('id', 'step-' + (idx + 1));\n			}\n\n			callCallback.call(this, 'applyStep', $(element), callbackData);\n		}\n		/**\n		 * Deinit a single step\n		 *\n		 * @param element the element of the step\n		 */\n		function doStepDeinit( element ) {\n			var stepData = $(element).data('stepData');\n\n			$(element).attr(\"style\", stepData.oldStyle);\n\n			callCallback.call(this, 'unapplyStep', $(element), {\n				stepData: stepData\n			});\n		}\n		/**\n		 * Reapplies stepData to the element\n		 *\n		 * @param element\n		 */\n		function doStepReapply( element ) {\n			callCallback.call(this, 'unapplyStep', $(element), {\n				stepData: element.data(\"stepData\")\n			});\n\n			callCallback.call(this, 'applyStep', $(element), {\n				stepData: element.data(\"stepData\")\n			});\n		}\n		/**\n		 * Completly deinit jmpress\n		 *\n		 */\n		function deinit() {\n			if ( active ) {\n				callCallback.call(this, 'setInactive', active, {\n					stepData: $(active).data('stepData')\n					,reason: \"deinit\"\n				} );\n			}\n			if (current.jmpressClass) {\n				$(jmpress).removeClass(current.jmpressClass);\n			}\n\n			callCallback.call(this, 'beforeDeinit', $(this), {});\n\n			$(settings.stepSelector, jmpress).each(function( idx ) {\n				doStepDeinit.call(jmpress, this );\n			});\n\n			container.attr(\"style\", oldStyle.container);\n			if(settings.fullscreen) {\n				$(\"html\").attr(\"style\", \"\");\n			}\n			area.attr(\"style\", oldStyle.area);\n			$(canvas).children().each(function() {\n				jmpress.append( $( this ) );\n			});\n			if( settings.fullscreen ) {\n				canvas.remove();\n			} else {\n				canvas.remove();\n				area.remove();\n			}\n\n			callCallback.call(this, 'afterDeinit', $(this), {});\n\n			$(jmpress).data(\"jmpressmethods\", false);\n		}\n		/**\n		 * Call a callback\n		 *\n		 * @param callbackName String callback which should be called\n		 * @param element some arguments to the callback\n		 * @param eventData\n		 */\n		function callCallback( callbackName, element, eventData ) {\n			eventData.settings = settings;\n			eventData.current = current;\n			eventData.container = container;\n			eventData.parents = element ? getStepParents(element) : null;\n			eventData.current = current;\n			eventData.jmpress = this;\n			var result = {};\n			$.each( settings[callbackName], function(idx, callback) {\n				result.value = callback.call( jmpress, element, eventData ) || result.value;\n			});\n			return result.value;\n		}\n		/**\n		 *\n		 */\n		function getStepParents( el ) {\n			return $(el).parentsUntil(jmpress).not(jmpress).filter(settings.stepSelector);\n		}\n		/**\n		 * Reselect the active step\n		 *\n		 * @param String type reason of reselecting step\n		 */\n		function reselect( type ) {\n			return select( { step: active, substep: activeSubstep }, type);\n		}\n		/**\n		 * Select a given step\n		 *\n		 * @param el element to select\n		 * @param type reason of changing step\n		 * @return Object element selected\n		 */\n		function select( el, type ) {\n			var substep;\n			if ( $.isPlainObject( el ) ) {\n				substep = el.substep;\n				el = el.step;\n			}\n			if ( typeof el === 'string') {\n				el = jmpress.find( el ).first();\n			}\n			if ( !el || !$(el).data('stepData') ) {\n				return false;\n			}\n\n			// Sometimes it's possible to trigger focus on first link with some keyboard action.\n			// Browser in such a case tries to scroll the page to make this element visible\n			// (even that body overflow is set to hidden) and it breaks our careful positioning.\n			//\n			// So, as a lousy (and lazy) workaround we will make the page scroll back to the top\n			// whenever slide is selected\n			//\n			// If you are reading this and know any better way to handle it, I'll be glad to hear about it!\n			scrollFix.call(this);\n\n			var step = $(el).data('stepData');\n\n			var cancelSelect = false;\n			callCallback.call(this, \"beforeChange\", el, {\n				stepData: step\n				,reason: type\n				,cancel: function() {\n					cancelSelect = true;\n				}\n			});\n			if (cancelSelect) {\n				return undefined;\n			}\n\n			var target = {};\n\n			var delegated = el;\n			if($(el).data(\"stepData\").delegate) {\n				delegated = $(el).parentsUntil(jmpress).filter(settings.stepSelector).filter(step.delegate) ||\n					$(el).near(step.delegate) ||\n					$(el).near(step.delegate, true) ||\n					$(step.delegate, jmpress);\n				step = delegated.data(\"stepData\");\n			}\n			if ( activeDelegated ) {\n				callCallback.call(this, 'setInactive', activeDelegated, {\n					stepData: $(activeDelegated).data('stepData')\n					,delegatedFrom: active\n					,reason: type\n					,target: target\n					,nextStep: delegated\n					,nextSubstep: substep\n					,nextStepData: step\n				} );\n			}\n			var callbackData = {\n				stepData: step\n				,delegatedFrom: el\n				,reason: type\n				,target: target\n				,substep: substep\n				,prevStep: activeDelegated\n				,prevSubstep: activeSubstep\n				,prevStepData: activeDelegated && $(activeDelegated).data('stepData')\n			};\n			callCallback.call(this, 'beforeActive', delegated, callbackData);\n			callCallback.call(this, 'setActive', delegated, callbackData);\n\n			// Set on step class on root element\n			if (current.jmpressClass) {\n				$(jmpress).removeClass(current.jmpressClass);\n			}\n			$(jmpress).addClass(current.jmpressClass = 'step-' + $(delegated).attr('id') );\n			if (current.jmpressDelegatedClass) {\n				$(jmpress).removeClass(current.jmpressDelegatedClass);\n			}\n			$(jmpress).addClass(current.jmpressDelegatedClass = 'delegating-step-' + $(el).attr('id') );\n\n			callCallback.call(this, \"applyTarget\", delegated, $.extend({\n				canvas: canvas\n				,area: area\n				,beforeActive: activeDelegated\n			}, callbackData));\n\n			active = el;\n			activeSubstep = callbackData.substep;\n			activeDelegated = delegated;\n\n			if(current.idleTimeout) {\n				clearTimeout(current.idleTimeout);\n			}\n			current.idleTimeout = setTimeout(function() {\n				callCallback.call(this, 'idle', delegated, callbackData);\n			}, Math.max(1, settings.transitionDuration - 100));\n\n			return delegated;\n		}\n		/**\n		 * This should fix ANY kind of buggy scrolling\n		 */\n		function scrollFix() {\n			function fix() {\n				if ($(container)[0].tagName === \"BODY\") {\n					window.scrollTo(0, 0);\n				}\n				$(container).scrollTop(0);\n				$(container).scrollLeft(0);\n				function check() {\n					if ($(container).scrollTop() !== 0 ||\n						$(container).scrollLeft() !== 0) {\n							fix();\n						}\n				}\n				setTimeout(check, 1);\n				setTimeout(check, 10);\n				setTimeout(check, 100);\n				setTimeout(check, 200);\n				setTimeout(check, 400);\n			}\n			fix();\n		}\n		/**\n		 * Alias for select\n		 */\n		function goTo( el ) {\n			return select.call(this, el, \"jump\" );\n		}\n		/**\n		 * Goto Next Slide\n		 *\n		 * @return Object newly active slide\n		 */\n		function next() {\n			return select.call(this, callCallback.call(this, 'selectNext', active, {\n				stepData: $(active).data('stepData')\n				,substep: activeSubstep\n			}), \"next\" );\n		}\n		/**\n		 * Goto Previous Slide\n		 *\n		 * @return Object newly active slide\n		 */\n		function prev() {\n			return select.call(this, callCallback.call(this, 'selectPrev', active, {\n				stepData: $(active).data('stepData')\n				,substep: activeSubstep\n			}), \"prev\" );\n		}\n		/**\n		 * Goto First Slide\n		 *\n		 * @return Object newly active slide\n		 */\n		function home() {\n			return select.call(this, callCallback.call(this, 'selectHome', active, {\n				stepData: $(active).data('stepData')\n			}), \"home\" );\n		}\n		/**\n		 * Goto Last Slide\n		 *\n		 * @return Object newly active slide\n		 */\n		function end() {\n			return select.call(this,   callCallback.call(this, 'selectEnd', active, {\n				stepData: $(active).data('stepData')\n			}), \"end\" );\n		}\n		/**\n		 * Manipulate the canvas\n		 *\n		 * @param props\n		 * @return Object\n		 */\n		function canvasMod( props ) {\n			css(canvas, props || {});\n			return $(canvas);\n		}\n		/**\n		 * Return current step\n		 *\n		 * @return Object\n		 */\n		function getActive() {\n			return activeDelegated && $(activeDelegated);\n		}\n		/**\n		 * fire a callback\n		 *\n		 * @param callbackName\n		 * @param element\n		 * @param eventData\n		 * @return void\n		 */\n		function fire( callbackName, element, eventData ) {\n			if( !callbacks[callbackName] ) {\n				$.error( \"callback \" + callbackName + \" is not registered.\" );\n			} else {\n				return callCallback.call(this, callbackName, element, eventData);\n			}\n		}\n\n		/**\n		 * PUBLIC METHODS LIST\n		 */\n		jmpress.data(\"jmpressmethods\", {\n			select: select\n			,reselect: reselect\n			,scrollFix: scrollFix\n			,goTo: goTo\n			,next: next\n			,prev: prev\n			,home: home\n			,end: end\n			,canvas: canvasMod\n			,container: function() { return container; }\n			,settings: function() { return settings; }\n			,active: getActive\n			,current: function() { return current; }\n			,fire: fire\n			,init: function(step) {\n				doStepInit.call(this, $(step), current.nextIdNumber++);\n			}\n			,deinit: function(step) {\n				if(step) {\n					doStepDeinit.call(this, $(step));\n				} else {\n					deinit.call(this);\n				}\n			}\n			,reapply: doStepReapply\n		});\n\n		/**\n		 * Check for support\n		 * This will be removed in near future, when support is coming\n		 *\n		 * @access protected\n		 * @return void\n		 */\n		function checkSupport() {\n			var ua = navigator.userAgent.toLowerCase();\n			var supported = ( ua.search(/(iphone)|(ipod)|(android)/) === -1 );\n			return supported;\n		}\n\n		// BEGIN INIT\n\n		// CHECK FOR SUPPORT\n		if (checkSupport() === false) {\n			if (settings.notSupportedClass) {\n				jmpress.addClass(settings.notSupportedClass);\n			}\n			return;\n		} else {\n			if (settings.notSupportedClass) {\n				jmpress.removeClass(settings.notSupportedClass);\n			}\n		}\n\n		// grabbing all steps\n		var steps = $(settings.stepSelector, jmpress);\n\n		// GERNERAL INIT OF FRAME\n		container = jmpress;\n		area = $('<div />');\n		canvas = $('<div />');\n		$(jmpress).children().filter(steps).each(function() {\n			canvas.append( $( this ) );\n		});\n		if(settings.fullscreen) {\n			container = $('body');\n			$(\"html\").css({\n				overflow: 'hidden'\n			});\n			area = jmpress;\n		}\n		oldStyle.area = area.attr(\"style\") || \"\";\n		oldStyle.container = container.attr(\"style\") || \"\";\n		if(settings.fullscreen) {\n			container.css({\n				height: '100%'\n			});\n			jmpress.append( canvas );\n		} else {\n			container.css({\n				position: \"relative\"\n			});\n			area.append( canvas );\n			jmpress.append( area );\n		}\n\n		$(container).addClass(settings.containerClass);\n		$(area).addClass(settings.areaClass);\n		$(canvas).addClass(settings.canvasClass);\n\n		document.documentElement.style.height = \"100%\";\n		container.css({\n			overflow: 'hidden'\n		});\n\n		var props = {\n			position: \"absolute\"\n			,transitionDuration: '0s'\n		};\n		props = $.extend({}, settings.animation, props);\n		css(area, props);\n		css(area, {\n			top: '50%'\n			,left: '50%'\n			,perspective: '1000px'\n		});\n		css(canvas, props);\n\n		current = {};\n\n		callCallback.call(this, 'beforeInit', null, {});\n\n		// INITIALIZE EACH STEP\n		steps.each(function( idx ) {\n			doStepInit.call(jmpress, this, idx );\n		});\n		current.nextIdNumber = steps.length;\n\n		callCallback.call(this, 'afterInit', null, {});\n\n		// START\n		select.call(this,  callCallback.call(this, 'selectInitialStep', \"init\", {}) );\n\n		if (settings.initClass) {\n			$(steps).removeClass(settings.initClass);\n		}\n	}\n	/**\n	 * Return default settings\n	 *\n	 * @return Object\n	 */\n	function getDefaults() {\n		return defaults;\n	}\n	/**\n	 * Register a callback or a jmpress function\n	 *\n	 * @access public\n	 * @param name String the name of the callback or function\n	 * @param func Function? the function to be added\n	 */\n	function register(name, func) {\n		if( $.isFunction(func) ) {\n			if( methods[name] ) {\n				$.error( \"function \" + name + \" is already registered.\" );\n			} else {\n				methods[name] = func;\n			}\n		} else {\n			if( callbacks[name] ) {\n				$.error( \"callback \" + name + \" is already registered.\" );\n			} else {\n				callbacks[name] = 1;\n				defaults[name] = [];\n			}\n		}\n	}\n	/**\n	 * Set CSS on element w/ prefixes\n	 *\n	 * @return Object element which properties were set\n	 *\n	 * TODO: Consider bypassing pfx and blindly set as jQuery\n	 * already checks for support\n	 */\n	function css( el, props ) {\n		var key, pkey, cssObj = {};\n		for ( key in props ) {\n			if ( props.hasOwnProperty(key) ) {\n				pkey = pfx(key);\n				if ( pkey !== null ) {\n					cssObj[pkey] = props[key];\n				}\n			}\n		}\n		$(el).css(cssObj);\n		return el;\n	}\n	/**\n	 * Return dataset for element\n	 *\n	 * @param el element\n	 * @return Object\n	 */\n	function dataset( el ) {\n		if ( $(el)[0].dataset ) {\n			return $.extend({}, $(el)[0].dataset);\n		}\n		function toCamelcase( str ) {\n			str = str.split( '-' );\n			for( var i = 1; i < str.length; i++ ) {\n				str[i] = str[i].substr(0, 1).toUpperCase() + str[i].substr(1);\n			}\n			return str.join( '' );\n		}\n		var returnDataset = {};\n		var attrs = $(el)[0].attributes;\n		$.each(attrs, function ( idx, attr ) {\n			if ( attr.nodeName.substr(0, 5) === \"data-\" ) {\n				returnDataset[ toCamelcase(attr.nodeName.substr(5)) ] = attr.nodeValue;\n			}\n		});\n		return returnDataset;\n	}\n	/**\n	 * Returns true, if jmpress is initialized\n	 *\n	 * @return bool\n	 */\n	function initialized() {\n		return !!$(this).data(\"jmpressmethods\");\n	}\n\n\n	/**\n	 * PUBLIC STATIC METHODS LIST\n	 */\n	var methods = {\n		init: init\n		,initialized: initialized\n		,deinit: function() {}\n		,css: css\n		,pfx: pfx\n		,defaults: getDefaults\n		,register: register\n		,dataset: dataset\n	};\n\n	/**\n	 * $.jmpress()\n	 */\n	$.fn.jmpress = function( method ) {\n		function f() {\n			var jmpressmethods = $(this).data(\"jmpressmethods\");\n			if ( jmpressmethods && jmpressmethods[method] ) {\n				return jmpressmethods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));\n			} else if ( methods[method] ) {\n				return methods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));\n			} else if ( callbacks[method] && jmpressmethods ) {\n				var settings = jmpressmethods.settings();\n				var func = Array.prototype.slice.call( arguments, 1 )[0];\n				if ($.isFunction( func )) {\n					settings[method] = settings[method] || [];\n					settings[method].push(func);\n				}\n			} else if ( typeof method === 'object' || ! method ) {\n				return init.apply( this, arguments );\n			} else {\n				$.error( 'Method ' +  method + ' does not exist on jQuery.jmpress' );\n			}\n			// to allow chaining\n			return this;\n		}\n		var args = arguments;\n		var result;\n		$(this).each(function(idx, element) {\n			result = f.apply(element, args);\n		});\n		return result;\n	};\n	$.extend({\n		jmpress: function( method ) {\n			if ( methods[method] ) {\n				return methods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));\n			} else if ( callbacks[method] ) {\n				// plugin interface\n				var func = Array.prototype.slice.call( arguments, 1 )[0];\n				if ($.isFunction( func )) {\n					defaults[method].push(func);\n				} else {\n					$.error( 'Second parameter should be a function: $.jmpress( callbackName, callbackFunction )' );\n				}\n			} else {\n				$.error( 'Method ' +  method + ' does not exist on jQuery.jmpress' );\n			}\n		}\n	});\n\n}(jQuery, document, window));"},106:function(a,b,c){a.exports='/*!\n * demo.js\n * Extras for running the main jmpress.js demo\n */\n(function( $, document, window, undefined ) {\n\n	\'use strict\';\n\n	var pageviewTimeout;\n\n	$.jmpress(\'register\', \'demo\', function() {\n	\n		$.jmpress("apply", "#showcase-nested", {\n			x: 250\n			,y: -30\n			,rotate: { z: 20 }\n			,secondary: {\n				rotateZ: 90\n				,y: 30\n				,"": "siblings"\n			}\n			,scale: 0.3\n		});\n		$.jmpress("template", "main", { children: [\n			{\n				scale: 10\n				,z: 1\n			},\n			{\n				x: -800\n				,y: -1100\n				,rotate: -20\n				,scale: 1.2\n			},\n			{\n				x: -700\n				,y: -500\n				,rotate: -40\n				,scale: 1.4\n			},\n			{\n				x: 0\n				,y: 100\n				,rotate: -60\n				,scale: 1.6\n			},\n			{\n				x: 1000\n				,y: 200\n				,rotate: -95\n				,scale: 1.8\n			},\n			{\n				x: 1800\n				,y: -100\n				,rotate: -120\n				,scale: 2\n			},\n			{\n				x: 2500\n				,y: -900\n				,z: -350\n				,rotate: -160\n				,rotateX: 40\n				,scale: 2.2\n			},\n			{\n				x: 2600\n				,y: -2500\n				,rotate: -210\n				,scale: 2.6\n			}\n		]});\n		$(\'#jmpress\').jmpress("route", ".step:not(#home)");\n		var jmpressConfig = {\n			// SET THE VIEW PORT\n			viewPort: {\n				height: 600\n				,width: 1000\n				,maxScale: 1 // do not scale up\n			}\n			// SET THE ACTIVE SLIDE IN THE NAV\n			,setActive: function( slide ) {\n				$(\'#nav a\')\n					.removeClass( \'ui-state-active\' )\n					.parent( \'li\' )\n						.removeClass( \'active\' );\n				var id = $(slide).attr(\'id\');\n				var idArr = id.split("-");\n				id = "";\n				for(var i = 0; i < idArr.length; i ++) {\n					if ( id ) {\n						id += "-";\n					}\n					id += idArr[i];\n					$(\'#nav a[href=\\"#\' + id + \'\\"]\')\n						.addClass( \'ui-state-active\' )\n						.parent( \'li\' )\n							.addClass( \'active\' );\n				}\n				// Track each step as page\n				if(pageviewTimeout) {\n					clearTimeout(pageviewTimeout);\n				}\n				pageviewTimeout = setTimeout(function() {\n					_gaq.push([\'_trackPageview\', "/jmpress.js/step-" + id]);\n				}, 1500);\n			}\n			// UPON STEP LOAD/ENCODE CODE SAMPLES\n			,afterStepLoaded: function( step, eventData ) {\n				$(step).find(\'code:not(.noconvert)\').each(function() {\n					$(this).text($(this).html()).html();\n				});\n				$("pre").addClass(\'ui-state-default\');\n			}\n			,afterInit: function( nil, eventData ) {\n				$("#nav").css("opacity", 1);\n				$("#reinit-jmpress").hide();\n				$("#uninit-jmpress").show();\n				$("#global-next").show();\n				$("#global-prev").show();\n				$("#read-docs").show();\n				$("#docs").show();\n				$(\'#home\').find(\'.notinner\').attr(\'class\', \'inner\').wrap(\'<div class="intro-top ui-state-default" />\');\n				$(\'#home\').find(\'.intro-bottom\').show();\n			}\n			,afterDeinit: function( nil, eventData ) {\n				$("#nav").css("opacity", 0);\n				$("#jmpress").addClass("normal-mode");\n				$("#reinit-jmpress").show();\n				$("#uninit-jmpress").hide();\n				$("#global-next").hide();\n				$("#global-prev").hide();\n				$("#read-docs").hide();\n				$("#docs").hide();\n				$(\'#home\').find(\'.intro-top .inner\').attr(\'class\', \'notinner\').unwrap();\n				$(\'#home\').find(\'.intro-bottom\').hide();\n			}\n			,containerClass: "ui-widget-content"\n			,areaClass: ""\n			,canvasClass: ""\n			,initClass: "init-css"\n			,notSupportedClass: "normal-mode"\n			,presentationMode: { notesUrl: "index.notes.html" }\n		};\n		$(\'#jmpress\').jmpress("toggle", 27, jmpressConfig, true);\n		$(\'.next\').click(function() {\n			$(\'#jmpress\').jmpress(\'next\');\n			return false;\n		});\n		$(\'.prev\').click(function() {\n			$(\'#jmpress\').jmpress(\'prev\');\n			return false;\n		});\n		$(\'.nested-next\').click(function() {\n			$(\'#nested-jmpress\').jmpress(\'next\');\n			_gaq.push([\'_trackEvent\', \'Feature\', \'NestedJmpress\', "start"]);\n			return false;\n		});\n		$("#jmpress a[href], #global-next, #global-prev").addClass("ui-state-default ui-corner-all");\n		$("#nav a, #nav-themes a").addClass("ui-button ui-widget ui-state-default");\n		$("#nav a span").addClass("ui-button-text");\n		//$(\'#home .intro-top, #home .intro-bottom\').addClass(\'\');\n		$("#jmpress a[href], #nav a, #nav-themes a, #global-next, #global-prev").hover(function() {\n			$(this).addClass("ui-state-hover");\n		}, function() {\n			$(this).removeClass("ui-state-hover");\n		});\n		// HACK TO CHANGE HINT IF IPAD\n		var ua = navigator.userAgent.toLowerCase();\n		if ( ua.search(/(ipad)/) !== -1 ) {\n			$(\'.hint\').text(\'Swipe support is coming :)\');\n		}\n\n		$("a[data-theme]").click(function(event) {\n			var theme = $(this).data("theme");\n\n			$("#theme").remove();\n\n			var link = $("<link>");\n			link.attr({\n					id: "theme",\n					type: \'text/css\',\n					rel: \'stylesheet\',\n					href: "http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.17/themes/"+theme+"/jquery-ui.css"\n			});\n			$("head").append( link );\n\n			$("a[data-theme]").removeClass("ui-state-active");\n			$(this).addClass("ui-state-active");\n\n			_gaq.push([\'_trackEvent\', \'Feature\', \'Theme\', theme]);\n\n			event.preventDefault();\n		});\n		$("a[data-theme=start]").addClass("ui-state-active");\n		$("#uninit-jmpress").click(function(event) {\n			$("#jmpress").jmpress("deinit");\n			window.location.hash = "";\n			event.preventDefault();\n\n			_gaq.push([\'_trackEvent\', \'Feature\', \'Deinit\', "deinit"]);\n		});\n		$("#reinit-jmpress").click(function(event) {\n			$("#jmpress").jmpress(jmpressConfig);\n			event.preventDefault();\n\n			_gaq.push([\'_trackEvent\', \'Feature\', \'Deinit\', "reinit"]);\n		});\n		$("#nested-jmpress").jmpress({\n			viewPort: {\n				height: 200\n				,width: 1000\n			}\n			,duration: { defaultValue: 3500, barSelector: "#nested-jmpress-bar" }\n			,containerClass: "ui-widget-content"\n			,hash: { use: false }\n			,stepSelector: ".nested-step"\n			,fullscreen: false\n			,presentationMode: { use: false }\n		});\n		setTimeout(function() {\n			$("#jmpress").removeClass("init-css");\n		}, 500);\n	\n	});\n\n}(jQuery, document, window));'},107:function(a,b,c){a.exports='/*!\n * hash.js\n * Detect and set the URL hash\n */\n(function( $, document, window, undefined ) {\n\n	\'use strict\';\n	var $jmpress = $.jmpress,\n		hashLink = "a[href^=#]";\n\n	/* FUNCTIONS */\n	function randomString() {\n		return "" + Math.round(Math.random() * 100000, 0);\n	}\n	/**\n	 * getElementFromUrl\n	 *\n	 * @return String or undefined\n	 */\n	function getElementFromUrl(settings) {\n		// get id from url # by removing `#` or `#/` from the beginning,\n		// so both "fallback" `#slide-id` and "enhanced" `#/slide-id` will work\n		// TODO SECURITY check user input to be valid!\n		try {\n			var el = $( \'#\' + window.location.hash.replace(/^#\\/?/,"") );\n			return el.length > 0 && el.is(settings.stepSelector) ? el : undefined;\n		} catch(e) {}\n	}\n	function setHash(stepid) {\n		var shouldBeHash = "#/" + stepid;\n		if(window.history && window.history.pushState) {\n			// shouldBeHash = "#" + stepid;\n			// consider this for future versions\n			//  it has currently issues, when startup with a link with hash (webkit)\n			if(window.location.hash !== shouldBeHash) {\n				window.history.pushState({}, \'\', shouldBeHash);\n			}\n		} else {\n			if(window.location.hash !== shouldBeHash) {\n				window.location.hash = shouldBeHash;\n			}\n		}\n	}\n\n	/* DEFAULTS */\n	$jmpress(\'defaults\').hash = {\n		use: true\n		,update: true\n		,bindChange: true\n		// NOTICE: {use: true, update: false, bindChange: true}\n		// will cause a error after clicking on a link to the current step\n	};\n\n	/* HOOKS */\n	$jmpress(\'selectInitialStep\', function( step, eventData ) {\n		var settings = eventData.settings,\n			hashSettings = settings.hash,\n			current = eventData.current,\n			jmpress = $(this);\n		eventData.current.hashNamespace = ".jmpress-"+randomString();\n		// HASH CHANGE EVENT\n		if ( hashSettings.use ) {\n			if ( hashSettings.bindChange ) {\n				$(window).bind(\'hashchange\'+current.hashNamespace, function(event) {\n					var urlItem = getElementFromUrl(settings);\n					if ( jmpress.jmpress(\'initialized\') ) {\n						jmpress.jmpress("scrollFix");\n					}\n					if(urlItem && urlItem.length) {\n						if(urlItem.attr("id") !== jmpress.jmpress("active").attr("id")) {\n							jmpress.jmpress(\'select\', urlItem);\n						}\n						setHash(urlItem.attr("id"));\n					}\n					event.preventDefault();\n				});\n				$(hashLink).on("click"+current.hashNamespace, function(event) {\n					var href = $(this).attr("href");\n					try {\n						if($(href).is(settings.stepSelector)) {\n							jmpress.jmpress("select", href);\n							event.preventDefault();\n							event.stopPropagation();\n						}\n					} catch(e) {}\n				});\n			}\n			return getElementFromUrl(settings);\n		}\n	});\n	$jmpress(\'afterDeinit\', function( nil, eventData ) {\n		$(hashLink).off(eventData.current.hashNamespace);\n		$(window).unbind(eventData.current.hashNamespace);\n	});\n	$jmpress(\'setActive\', function( step, eventData ) {\n		var settings = eventData.settings,\n			current = eventData.current;\n		// `#/step-id` is used instead of `#step-id` to prevent default browser\n		// scrolling to element in hash\n		if ( settings.hash.use && settings.hash.update ) {\n			clearTimeout(current.hashtimeout);\n			current.hashtimeout = setTimeout(function() {\n				setHash($(eventData.delegatedFrom).attr(\'id\'));\n			}, settings.transitionDuration + 200);\n		}\n	});\n\n}(jQuery, document, window));'},108:function(a,b,c){a.exports='/*!\n * jqevents.js\n * Fires jQuery events\n */\n(function( $, document, window, undefined ) {\n\n	\'use strict\';\n\n	/* HOOKS */\n	// the events should not bubble up the tree\n	// elsewise nested jmpress would cause buggy behavior\n	$.jmpress("setActive", function( step, eventData ) {\n		if(eventData.prevStep !== step) {\n			$(step).triggerHandler("enterStep");\n		}\n	});\n	$.jmpress("setInactive", function( step, eventData ) {\n		if(eventData.nextStep !== step) {\n			$(step).triggerHandler("leaveStep");\n		}\n	});\n\n}(jQuery, document, window));'},109:function(a,b,c){a.exports='/*!\n * keyboard.js\n * Keyboard event mapping and default keyboard actions\n */\n(function( $, document, window, undefined ) {\n\n	\'use strict\';\n	var $jmpress = $.jmpress,\n		jmpressNext = "next",\n		jmpressPrev = "prev";\n\n	/* FUNCTIONS */\n	function randomString() {\n		return "" + Math.round(Math.random() * 100000, 0);\n	}\n	function stopEvent(event) {\n		event.preventDefault();\n		event.stopPropagation();\n	}\n\n	/* DEFAULTS */\n	$jmpress(\'defaults\').keyboard = {\n		use: true\n		,keys: {\n			33: jmpressPrev // pg up\n			,37: jmpressPrev // left\n			,38: jmpressPrev // up\n\n			,9: jmpressNext+":"+jmpressPrev // tab\n			,32: jmpressNext // space\n			,34: jmpressNext // pg down\n			,39: jmpressNext // right\n			,40: jmpressNext // down\n\n			,36: "home" // home\n\n			,35: "end" // end\n		}\n		,ignore: {\n			"INPUT": [\n				32 // space\n				,37 // left\n				,38 // up\n				,39 // right\n				,40 // down\n			]\n			,"TEXTAREA": [\n				32 // space\n				,37 // left\n				,38 // up\n				,39 // right\n				,40 // down\n			]\n			,"SELECT": [\n				38 // up\n				,40 // down\n			]\n		}\n		,tabSelector: "a[href]:visible, :input:visible"\n	};\n\n	/* HOOKS */\n	$jmpress(\'afterInit\', function( nil, eventData ) {\n		var settings = eventData.settings,\n			keyboardSettings = settings.keyboard,\n			ignoreKeyboardSettings = keyboardSettings.ignore,\n			current = eventData.current,\n			jmpress = $(this);\n\n		// tabindex make it focusable so that it can recieve key events\n		if(!settings.fullscreen) {\n			jmpress.attr("tabindex", 0);\n		}\n\n		current.keyboardNamespace = ".jmpress-"+randomString();\n\n		// KEYPRESS EVENT: this fixes a Opera bug\n		$(settings.fullscreen ? document : jmpress)\n			.bind("keypress"+current.keyboardNamespace, function( event ) {\n\n			for( var nodeName in ignoreKeyboardSettings ) {\n				if ( event.target.nodeName === nodeName && ignoreKeyboardSettings[nodeName].indexOf(event.which) !== -1 ) {\n					return;\n				}\n			}\n			if(event.which >= 37 && event.which <= 40 || event.which === 32) {\n				stopEvent(event);\n			}\n		});\n		// KEYDOWN EVENT\n		$(settings.fullscreen ? document : jmpress)\n			.bind("keydown"+current.keyboardNamespace, function( event ) {\n			var eventTarget = $(event.target);\n\n			if ( !settings.fullscreen && !eventTarget.closest(jmpress).length || !keyboardSettings.use ) {\n				return;\n			}\n\n			for( var nodeName in ignoreKeyboardSettings ) {\n				if ( eventTarget[0].nodeName === nodeName && ignoreKeyboardSettings[nodeName].indexOf(event.which) !== -1 ) {\n					return;\n				}\n			}\n\n			var reverseSelect = false;\n			var nextFocus;\n			if (event.which === 9) {\n				// tab\n				if ( !eventTarget.closest( jmpress.jmpress(\'active\') ).length ) {\n					if ( !event.shiftKey ) {\n						nextFocus = jmpress.jmpress(\'active\').find("a[href], :input").filter(":visible").first();\n					} else {\n						reverseSelect = true;\n					}\n				} else {\n					nextFocus = eventTarget.near( keyboardSettings.tabSelector, event.shiftKey );\n					if( !$(nextFocus)\n						.closest( settings.stepSelector )\n						.is(jmpress.jmpress(\'active\') ) ) {\n						nextFocus = undefined;\n					}\n				}\n				if( nextFocus && nextFocus.length > 0 ) {\n					nextFocus.focus();\n					jmpress.jmpress("scrollFix");\n					stopEvent(event);\n					return;\n				} else {\n					if(event.shiftKey) {\n						reverseSelect = true;\n					}\n				}\n			}\n\n			var action = keyboardSettings.keys[ event.which ];\n			if ( typeof action === "string" ) {\n				if (action.indexOf(":") !== -1) {\n					action = action.split(":");\n					action = event.shiftKey ? action[1] : action[0];\n				}\n				jmpress.jmpress( action );\n				stopEvent(event);\n			} else if ( $.isFunction(action) ) {\n				action.call(jmpress, event);\n			} else if ( action ) {\n				jmpress.jmpress.apply( jmpress, action );\n				stopEvent(event);\n			}\n\n			if (reverseSelect) {\n				// tab\n				nextFocus = jmpress.jmpress(\'active\').find("a[href], :input").filter(":visible").last();\n				nextFocus.focus();\n				jmpress.jmpress("scrollFix");\n			}\n		});\n	});\n	$jmpress(\'afterDeinit\', function( nil, eventData ) {\n		$(document).unbind(eventData.current.keyboardNamespace);\n	});\n\n\n}(jQuery, document, window));'},110:function(a,b,c){a.exports='/*!\n * mobile.js\n * Adds support for swipe on touch supported browsers\n */\n(function( $, document, window, undefined ) {\n\n	\'use strict\';\n	var $jmpress = $.jmpress;\n\n	/* FUNCTIONS */\n	function randomString() {\n		return "" + Math.round(Math.random() * 100000, 0);\n	}\n\n	/* HOOKS */\n	$jmpress( \'afterInit\', function( step, eventData ) {\n		var settings = eventData.settings,\n			current = eventData.current,\n			jmpress = eventData.jmpress;\n		current.mobileNamespace = ".jmpress-"+randomString();\n		var data, start = [0,0];\n		$(settings.fullscreen ? document : jmpress)\n			.bind("touchstart"+current.mobileNamespace, function( event ) {\n\n			data = event.originalEvent.touches[0];\n			start = [ data.pageX, data.pageY ];\n\n		}).bind("touchmove"+current.mobileNamespace, function( event ) {\n			data = event.originalEvent.touches[0];\n			event.preventDefault();\n			return false;\n		}).bind("touchend"+current.mobileNamespace, function( event ) {\n			var end = [ data.pageX, data.pageY ],\n				diff = [ end[0]-start[0], end[1]-start[1] ];\n\n			if(Math.max(Math.abs(diff[0]), Math.abs(diff[1])) > 50) {\n				diff = Math.abs(diff[0]) > Math.abs(diff[1]) ? diff[0] : diff[1];\n				$(jmpress).jmpress(diff > 0 ? "prev" : "next");\n				event.preventDefault();\n				return false;\n			}\n		});\n	});\n	$jmpress(\'afterDeinit\', function( nil, eventData ) {\n		var settings = eventData.settings,\n			current = eventData.current,\n			jmpress = eventData.jmpress;\n		$(settings.fullscreen ? document : jmpress).unbind(current.mobileNamespace);\n	});\n\n}(jQuery, document, window));'},111:function(a,b,c){a.exports='/*!\n * mouse.js\n * Clicking to select a step\n */\n(function( $, document, window, undefined ) {\n\n	\'use strict\';\n	var $jmpress = $.jmpress;\n\n	/* FUNCTIONS */\n	function randomString() {\n		return "" + Math.round(Math.random() * 100000, 0);\n	}\n\n	/* DEFAULTS */\n	$jmpress("defaults").mouse = {\n		clickSelects: true\n	};\n\n	/* HOOKS */\n	$jmpress("afterInit", function( nil, eventData ) {\n		var settings = eventData.settings,\n			stepSelector = settings.stepSelector,\n			current = eventData.current,\n			jmpress = $(this);\n		current.clickableStepsNamespace = ".jmpress-"+randomString();\n		jmpress.bind("click"+current.clickableStepsNamespace, function(event) {\n			if (!settings.mouse.clickSelects || current.userZoom) {\n				return;\n			}\n\n			// get clicked step\n			var clickedStep = $(event.target).closest(stepSelector);\n\n			// clicks on the active step do default\n			if ( clickedStep.is( jmpress.jmpress("active") ) ) {\n				return;\n			}\n\n			if (clickedStep.length) {\n				// select the clicked step\n				jmpress.jmpress("select", clickedStep[0], "click");\n				event.preventDefault();\n				event.stopPropagation();\n			}\n		});\n	});\n	$jmpress(\'afterDeinit\', function( nil, eventData ) {\n		$(this).unbind(eventData.current.clickableStepsNamespace);\n	});\n\n}(jQuery, document, window));'},112:function(a,b,c){a.exports='/*!\n * near.js\n * Find steps near each other\n */\n(function( $, document, window, undefined ) {\n\n	\'use strict\';\n\n	// add near( selector, backwards = false) to jquery\n\n\n	function checkAndGo( elements, func, selector, backwards ) {\n		var next;\n		elements.each(function(idx, element) {\n			if(backwards) {\n				next = func(element, selector, backwards);\n				if (next) {\n					return false;\n				}\n			}\n			if( $(element).is(selector) ) {\n				next = element;\n				return false;\n			}\n			if(!backwards) {\n				next = func(element, selector, backwards);\n				if (next) {\n					return false;\n				}\n			}\n		});\n		return next;\n	}\n	function findNextInChildren(item, selector, backwards) {\n		var children = $(item).children();\n		if(backwards) {\n			children = $(children.get().reverse());\n		}\n		return checkAndGo( children, findNextInChildren, selector, backwards );\n	}\n	function findNextInSiblings(item, selector, backwards) {\n		return checkAndGo(\n			$(item)[backwards ? "prevAll" : "nextAll"](),\n			findNextInChildren, selector, backwards );\n	}\n	function findNextInParents(item, selector, backwards) {\n		var next;\n		var parents = $(item).parents();\n		parents = $(parents.get());\n		$.each(parents.get(), function(idx, element) {\n			if( backwards && $(element).is(selector) ) {\n				next = element;\n				return false;\n			}\n			next = findNextInSiblings(element, selector, backwards);\n			if(next) {\n				return false;\n			}\n		});\n		return next;\n	}\n\n	$.fn.near = function( selector, backwards ) {\n		var array = [];\n		$(this).each(function(idx, element) {\n			var near = (backwards ?\n					false :\n					findNextInChildren( element, selector, backwards )) ||\n				findNextInSiblings( element, selector, backwards ) ||\n				findNextInParents( element, selector, backwards );\n			if( near ) {\n				array.push(near);\n			}\n		});\n		return $(array);\n	};\n}(jQuery, document, window));'},113:function(a,b,c){a.exports="/*!\n * start.js\n * Set the first step to start on\n */\n(function( $, document, window, undefined ) {\n\n	'use strict';\n\n	/* HOOKS */\n	$.jmpress( 'selectInitialStep', function( nil, eventData ) {\n		return eventData.settings.start;\n	});\n\n}(jQuery, document, window));"},114:function(a,b,c){a.exports='/*!\n * templates.js\n * The amazing template engine\n */\n(function( $, document, window, undefined ) {\n\n	\'use strict\';\n	var $jmpress = $.jmpress,\n		templateFromParentIdent = "_template_",\n		templateFromApplyIdent = "_applied_template_";\n\n	/* STATIC VARS */\n	var templates = {};\n\n	/* FUNCTIONS */\n	function randomString() {\n		return "" + Math.round(Math.random() * 100000, 0);\n	}\n	function addUndefined( target, values, prefix ) {\n		for( var name in values ) {\n			var targetName = name;\n			if ( prefix ) {\n				targetName = prefix + targetName.substr(0, 1).toUpperCase() + targetName.substr(1);\n			}\n			if ( $.isPlainObject(values[name]) ) {\n				addUndefined( target, values[name], targetName );\n			} else if( target[targetName] === undefined ) {\n				target[targetName] = values[name];\n			}\n		}\n	}\n	function applyChildrenTemplates( children, templateChildren ) {\n		if ($.isArray(templateChildren)) {\n			if (templateChildren.length < children.length) {\n				$.error("more nested steps than children in template");\n			} else {\n				children.each(function(idx, child) {\n					child = $(child);\n					var tmpl = child.data(templateFromParentIdent) || {};\n					addUndefined(tmpl, templateChildren[idx]);\n					child.data(templateFromParentIdent, tmpl);\n				});\n			}\n		} else if($.isFunction(templateChildren)) {\n			children.each(function(idx, child) {\n				child = $(child);\n				var tmpl = child.data(templateFromParentIdent) || {};\n				addUndefined(tmpl, templateChildren(idx, child, children));\n				child.data(templateFromParentIdent, tmpl);\n			});\n		} // TODO: else if(object)\n	}\n	function applyTemplate( data, element, template, eventData ) {\n		if (template.children) {\n			var children = element.children( eventData.settings.stepSelector );\n			applyChildrenTemplates( children, template.children );\n		}\n		applyTemplateData( data, template );\n	}\n	function applyTemplateData( data, template ) {\n		addUndefined(data, template);\n	}\n\n	/* HOOKS */\n	$jmpress("beforeInitStep", function( step, eventData ) {\n		step = $(step);\n		var data = eventData.data,\n			templateFromAttr = data.template,\n			templateFromApply = step.data(templateFromApplyIdent),\n			templateFromParent = step.data(templateFromParentIdent);\n		if(templateFromAttr) {\n			$.each(templateFromAttr.split(" "), function(idx, tmpl) {\n				var template = templates[tmpl];\n				applyTemplate( data, step, template, eventData );\n			});\n		}\n		if (templateFromApply) {\n			applyTemplate( data, step, templateFromApply, eventData );\n		}\n		if (templateFromParent) {\n			applyTemplate( data, step, templateFromParent, eventData );\n			step.data(templateFromParentIdent, null);\n			if(templateFromParent.template) {\n				$.each(templateFromParent.template.split(" "), function(idx, tmpl) {\n					var template = templates[tmpl];\n					applyTemplate( data, step, template, eventData );\n				});\n			}\n		}\n	});\n	$jmpress("beforeInit", function( nil, eventData ) {\n		var data = $jmpress("dataset", this),\n			dataTemplate = data.template,\n			stepSelector = eventData.settings.stepSelector;\n		if (dataTemplate) {\n			var template = templates[dataTemplate];\n			applyChildrenTemplates( $(this).find(stepSelector).filter(function() {\n				return !$(this).parent().is(stepSelector);\n			}), template.children );\n		}\n	});\n\n	/* EXPORTED FUNCTIONS */\n	$jmpress("register", "template", function( name, tmpl ) {\n		if (templates[name]) {\n			templates[name] = $.extend(true, {}, templates[name], tmpl);\n		} else {\n			templates[name] = $.extend(true, {}, tmpl);\n		}\n	});\n	$jmpress("register", "apply", function( selector, tmpl ) {\n		if( !tmpl ) {\n			// TODO ERROR because settings not found\n			var stepSelector = $(this).jmpress("settings").stepSelector;\n			applyChildrenTemplates( $(this).find(stepSelector).filter(function() {\n				return !$(this).parent().is(stepSelector);\n			}), selector );\n		} else if($.isArray(tmpl)) {\n			applyChildrenTemplates( $(selector), tmpl );\n		} else {\n			var template;\n			if(typeof tmpl === "string") {\n				template = templates[tmpl];\n			} else {\n				template = $.extend(true, {}, tmpl);\n			}\n			$(selector).each(function(idx, element) {\n				element = $(element);\n				var tmpl = element.data(templateFromApplyIdent) || {};\n				addUndefined(tmpl, template);\n				element.data(templateFromApplyIdent, tmpl);\n			});\n		}\n	});\n\n}(jQuery, document, window));'},115:function(a,b,c){a.exports='/*!\n * transform.js\n * The engine that powers the transforms or falls back to other methods\n */\n(function( $, document, window, undefined ) {\n\n	\'use strict\';\n\n	/* FUNCTIONS */\n	function randomString() {\n		return "" + Math.round(Math.random() * 100000, 0);\n	}\n	function toCssNumber(number) {\n		return (Math.round(10000*number)/10000)+"";\n	}\n\n	/**\n	 * 3D and 2D engines\n	 */\n	var engines = {\n		3: {\n			transform: function( el, data ) {\n				var transform = \'translate(-50%,-50%)\';\n				$.each(data, function(idx, item) {\n					var coord = ["X", "Y", "Z"];\n					var i;\n					if(item[0] === "translate") { // ["translate", x, y, z]\n						transform += " translate3d(" + toCssNumber(item[1] || 0) + "px," + toCssNumber(item[2] || 0) + "px," + toCssNumber(item[3] || 0) + "px)";\n					} else if(item[0] === "rotate") {\n						var order = item[4] ? [1, 2, 3] : [3, 2, 1];\n						for(i = 0; i < 3; i++) {\n							transform += " rotate" + coord[order[i]-1] + "(" + toCssNumber(item[order[i]] || 0) + "deg)";\n						}\n					} else if(item[0] === "scale") {\n						for(i = 0; i < 3; i++) {\n							transform += " scale" + coord[i] + "(" + toCssNumber(item[i+1] || 1) + ")";\n						}\n					}\n				});\n				$.jmpress("css", el, $.extend({}, { transform: transform }));\n			}\n		}\n		,2: {\n			transform: function( el, data ) {\n				var transform = \'translate(-50%,-50%)\';\n				$.each(data, function(idx, item) {\n					var coord = ["X", "Y"];\n					if(item[0] === "translate") { // ["translate", x, y, z]\n						transform += " translate(" + toCssNumber(item[1] || 0) + "px," + toCssNumber(item[2] || 0) + "px)";\n					} else if(item[0] === "rotate") {\n						transform += " rotate(" + toCssNumber(item[3] || 0) + "deg)";\n					} else if(item[0] === "scale") {\n						for(var i = 0; i < 2; i++) {\n							transform += " scale" + coord[i] + "(" + toCssNumber(item[i+1] || 1) + ")";\n						}\n					}\n				});\n				$.jmpress("css", el, $.extend({}, { transform: transform }));\n			}\n		}\n		,1: {\n			// CHECK IF SUPPORT IS REALLY NEEDED?\n			// this not even work without scaling...\n			// it may better to display the normal view\n			transform: function( el, data ) {\n				var anitarget = { top: 0, left: 0 };\n				$.each(data, function(idx, item) {\n					var coord = ["X", "Y"];\n					if(item[0] === "translate") { // ["translate", x, y, z]\n						anitarget.left = Math.round(item[1] || 0) + "px";\n						anitarget.top = Math.round(item[2] || 0) + "px";\n					}\n				});\n				el.animate(anitarget, 1000); // TODO: Use animation duration\n			}\n		}\n	};\n\n	/**\n	 * Engine to power cross-browser translate, scale and rotate.\n	 */\n	var engine = (function() {\n		if ($.jmpress("pfx", "perspective")) {\n			return engines[3];\n		} else if ($.jmpress("pfx", "transform")) {\n			return engines[2];\n		} else {\n			// CHECK IF SUPPORT IS REALLY NEEDED?\n			return engines[1];\n		}\n	}());\n\n	$.jmpress("defaults").reasonableAnimation = {};\n	$.jmpress("initStep", function( step, eventData ) {\n		var data = eventData.data;\n		var stepData = eventData.stepData;\n		var pf = parseFloat;\n		$.extend(stepData, {\n			x: pf(data.x) || 0\n			,y: pf(data.y) || 0\n			,z: pf(data.z) || 0\n			,r: pf(data.r) || 0\n			,phi: pf(data.phi) || 0\n			,rotate: pf(data.rotate) || 0\n			,rotateX: pf(data.rotateX) || 0\n			,rotateY: pf(data.rotateY) || 0\n			,rotateZ: pf(data.rotateZ) || 0\n			,revertRotate: false\n			,scale: pf(data.scale) || 1\n			,scaleX: pf(data.scaleX) || false\n			,scaleY: pf(data.scaleY) || false\n			,scaleZ: pf(data.scaleZ) || 1\n		});\n	});\n	$.jmpress("afterInit", function( nil, eventData ) {\n		var stepSelector = eventData.settings.stepSelector,\n			current = eventData.current;\n		current.perspectiveScale = 1;\n		current.maxNestedDepth = 0;\n		var nestedSteps = $(eventData.jmpress).find(stepSelector).children(stepSelector);\n		while(nestedSteps.length) {\n			current.maxNestedDepth++;\n			nestedSteps = nestedSteps.children(stepSelector);\n		}\n	});\n	$.jmpress("applyStep", function( step, eventData ) {\n		$.jmpress("css", $(step), {\n			position: "absolute"\n			,transformStyle: "preserve-3d"\n		});\n		if ( eventData.parents.length > 0 ) {\n			$.jmpress("css", $(step), {\n				top: "50%"\n				,left: "50%"\n			});\n		}\n		var sd = eventData.stepData;\n		var transform = [\n			["translate",\n				sd.x || (sd.r * Math.sin(sd.phi*Math.PI/180)),\n				sd.y || (-sd.r * Math.cos(sd.phi*Math.PI/180)),\n				sd.z],\n			["rotate",\n				sd.rotateX,\n				sd.rotateY,\n				sd.rotateZ || sd.rotate,\n				true],\n			["scale",\n				sd.scaleX || sd.scale,\n				sd.scaleY || sd.scale,\n				sd.scaleZ || sd.scale]\n		];\n		engine.transform( step, transform );\n	});\n	$.jmpress("setActive", function( element, eventData ) {\n		var target = eventData.target;\n		var step = eventData.stepData;\n		var tf = target.transform = [];\n		target.perspectiveScale = 1;\n\n		for(var i = eventData.current.maxNestedDepth; i > (eventData.parents.length || 0); i--) {\n			tf.push(["scale"], ["rotate"], ["translate"]);\n		}\n\n		tf.push(["scale",\n			1 / (step.scaleX || step.scale),\n			1 / (step.scaleY || step.scale),\n			1 / (step.scaleZ)]);\n		tf.push(["rotate",\n			-step.rotateX,\n			-step.rotateY,\n			-(step.rotateZ || step.rotate)]);\n		tf.push(["translate",\n			-(step.x || (step.r * Math.sin(step.phi*Math.PI/180))),\n			-(step.y || (-step.r * Math.cos(step.phi*Math.PI/180))),\n			-step.z]);\n		target.perspectiveScale *= (step.scaleX || step.scale);\n\n		$.each(eventData.parents, function(idx, element) {\n			var step = $(element).data("stepData");\n			tf.push(["scale",\n				1 / (step.scaleX || step.scale),\n				1 / (step.scaleY || step.scale),\n				1 / (step.scaleZ)]);\n			tf.push(["rotate",\n				-step.rotateX,\n				-step.rotateY,\n				-(step.rotateZ || step.rotate)]);\n			tf.push(["translate",\n				-(step.x || (step.r * Math.sin(step.phi*Math.PI/180))),\n				-(step.y || (-step.r * Math.cos(step.phi*Math.PI/180))),\n				-step.z]);\n			target.perspectiveScale *= (step.scaleX || step.scale);\n		});\n\n		$.each(tf, function(idx, item) {\n			if(item[0] !== "rotate") {\n				return;\n			}\n			function lowRotate(name) {\n				if(eventData.current["rotate"+name+"-"+idx] === undefined) {\n					eventData.current["rotate"+name+"-"+idx] = item[name] || 0;\n				}\n				var cur = eventData.current["rotate"+name+"-"+idx], tar = item[name] || 0,\n					curmod = cur % 360, tarmod = tar % 360;\n				if(curmod < 0) {\n					curmod += 360;\n				}\n				if(tarmod < 0) {\n					tarmod += 360;\n				}\n				var diff = tarmod - curmod;\n				if(diff < -180) {\n					diff += 360;\n				} else if(diff > 180) {\n					diff -= 360;\n				}\n				eventData.current["rotate"+name+"-"+idx] = item[name] = cur + diff;\n			}\n			lowRotate(1);\n			lowRotate(2);\n			lowRotate(3);\n		});\n	});\n	$.jmpress("applyTarget", function( active, eventData ) {\n\n		var target = eventData.target,\n			props, step = eventData.stepData,\n			settings = eventData.settings,\n			zoomin = target.perspectiveScale * 1.3 < eventData.current.perspectiveScale,\n			zoomout = target.perspectiveScale > eventData.current.perspectiveScale * 1.3;\n\n		// extract first scale from transform\n		var lastScale = -1;\n		$.each(target.transform, function(idx, item) {\n			if(item.length <= 1) {\n				return;\n			}\n			if(item[0] === "rotate" &&\n				item[1] % 360 === 0  &&\n				item[2] % 360 === 0  &&\n				item[3] % 360 === 0) {\n				return;\n			}\n			if(item[0] === "scale") {\n				lastScale = idx;\n			} else {\n				return false;\n			}\n		});\n\n		if(lastScale !== eventData.current.oldLastScale) {\n			zoomin = zoomout = false;\n			eventData.current.oldLastScale = lastScale;\n		}\n\n		var extracted = [];\n		if(lastScale !== -1) {\n			while(lastScale >= 0) {\n				if(target.transform[lastScale][0] === "scale") {\n					extracted.push(target.transform[lastScale]);\n					target.transform[lastScale] = ["scale"];\n				}\n				lastScale--;\n			}\n		}\n\n		var animation = settings.animation;\n		if(settings.reasonableAnimation[eventData.reason]) {\n			animation = $.extend({},\n				animation,\n				settings.reasonableAnimation[eventData.reason]);\n		}\n\n		props = {\n			// to keep the perspective look similar for different scales\n			// we need to \'scale\' the perspective, too\n			perspective: Math.round(target.perspectiveScale * 1000) + "px"\n		};\n		props = $.extend({}, animation, props);\n		if (!zoomin) {\n			props.transitionDelay = \'0s\';\n		}\n		if (!eventData.beforeActive) {\n			props.transitionDuration = \'0s\';\n			props.transitionDelay = \'0s\';\n		}\n		$.jmpress("css", eventData.area, props);\n		engine.transform(eventData.area, extracted);\n\n		props = $.extend({}, animation);\n		if (!zoomout) {\n			props.transitionDelay = \'0s\';\n		}\n		if (!eventData.beforeActive) {\n			props.transitionDuration = \'0s\';\n			props.transitionDelay = \'0s\';\n		}\n\n		eventData.current.perspectiveScale = target.perspectiveScale;\n\n		$.jmpress("css", eventData.canvas, props);\n		engine.transform(eventData.canvas, target.transform);\n	});\n\n}(jQuery, document, window));'},116:function(a,b,c){a.exports='/*!\n * viewport.js\n * Scale to fit a given viewport\n */\n(function( $, document, window, undefined ) {\n\n	\'use strict\';\n\n	function randomString() {\n		return "" + Math.round(Math.random() * 100000, 0);\n	}\n\n	var defaults = $.jmpress("defaults");\n	defaults.viewPort = {\n		width: false\n		,height: false\n		,maxScale: 0\n		,minScale: 0\n		,zoomable: 0\n		,zoomBindMove: true\n		,zoomBindWheel: true\n	};\n	var keys = defaults.keyboard.keys;\n	keys[$.browser.mozilla?107:187] = "zoomIn";  // +\n	keys[$.browser.mozilla?109:189] = "zoomOut"; // -\n	defaults.reasonableAnimation.resize = {\n		transitionDuration: \'0s\'\n		,transitionDelay: \'0ms\'\n	};\n	defaults.reasonableAnimation.zoom = {\n		transitionDuration: \'0s\'\n		,transitionDelay: \'0ms\'\n	};\n	$.jmpress("initStep", function( step, eventData ) {\n		for(var variable in {"viewPortHeight":1, "viewPortWidth":1, "viewPortMinScale":1, "viewPortMaxScale":1, "viewPortZoomable":1}) {\n			eventData.stepData[variable] = eventData.data[variable] && parseFloat(eventData.data[variable]);\n		}\n	});\n	$.jmpress("afterInit", function( nil, eventData ) {\n		var jmpress = this;\n		eventData.current.viewPortNamespace = ".jmpress-"+randomString();\n		$(window).bind("resize"+eventData.current.viewPortNamespace, function (event) {\n			$(jmpress).jmpress("reselect", "resize");\n		});\n		eventData.current.userZoom = 0;\n		eventData.current.userTranslateX = 0;\n		eventData.current.userTranslateY = 0;\n		if(eventData.settings.viewPort.zoomBindWheel) {\n			$(eventData.settings.fullscreen ? document : this)\n				.bind("mousewheel"+eventData.current.viewPortNamespace, function( event, delta ) {\n				delta = delta || event.originalEvent.wheelDelta;\n				var direction = (delta / Math.abs(delta));\n				if(direction < 0) {\n					$(eventData.jmpress).jmpress("zoomOut", event.originalEvent.x, event.originalEvent.y);\n				} else if(direction > 0) {\n					$(eventData.jmpress).jmpress("zoomIn", event.originalEvent.x, event.originalEvent.y);\n				}\n			});\n		}\n		if(eventData.settings.viewPort.zoomBindMove) {\n			$(eventData.settings.fullscreen ? document : this).bind("mousedown"+eventData.current.viewPortNamespace, function (event) {\n				if(eventData.current.userZoom) {\n					eventData.current.userTranslating = { x: event.clientX, y: event.clientY };\n					event.preventDefault();\n					event.stopImmediatePropagation();\n				}\n			}).bind("mousemove"+eventData.current.viewPortNamespace, function (event) {\n				var userTranslating = eventData.current.userTranslating;\n				if(userTranslating) {\n					$(jmpress).jmpress("zoomTranslate", event.clientX - userTranslating.x, event.clientY - userTranslating.y);\n					userTranslating.x = event.clientX;\n					userTranslating.y = event.clientY;\n					event.preventDefault();\n					event.stopImmediatePropagation();\n				}\n			}).bind("mouseup"+eventData.current.viewPortNamespace, function (event) {\n				if(eventData.current.userTranslating) {\n					eventData.current.userTranslating = undefined;\n					event.preventDefault();\n					event.stopImmediatePropagation();\n				}\n			});\n		}\n	});\n	function maxAbs(value, range) {\n		return Math.max(Math.min(value, range), -range);\n	}\n	function zoom(x, y, direction) {\n		var current = $(this).jmpress("current"),\n			settings = $(this).jmpress("settings"),\n			stepData = $(this).jmpress("active").data("stepData"),\n			container = $(this).jmpress("container");\n		if(current.userZoom === 0 && direction < 0) {\n			return;\n		}\n		var zoomableSteps = stepData.viewPortZoomable || settings.viewPort.zoomable;\n		if(current.userZoom === zoomableSteps && direction > 0) {\n			return;\n		}\n		current.userZoom += direction;\n\n		var halfWidth = $(container).innerWidth()/2,\n			halfHeight = $(container).innerHeight()/2;\n\n		x = x ? x - halfWidth : x;\n		y = y ? y - halfHeight : y;\n\n		// TODO this is not perfect... too much math... :(\n		current.userTranslateX =\n			maxAbs(current.userTranslateX - direction * x / current.zoomOriginWindowScale / zoomableSteps,\n			halfWidth * current.userZoom * current.userZoom / zoomableSteps);\n		current.userTranslateY =\n			maxAbs(current.userTranslateY - direction * y / current.zoomOriginWindowScale / zoomableSteps,\n			halfHeight * current.userZoom * current.userZoom / zoomableSteps);\n\n		$(this).jmpress("reselect", "zoom");\n	}\n	$.jmpress("register", "zoomIn", function(x, y) {\n		zoom.call(this, x||0, y||0, 1);\n	});\n	$.jmpress("register", "zoomOut", function(x, y) {\n		zoom.call(this, x||0, y||0, -1);\n	});\n	$.jmpress("register", "zoomTranslate", function(x, y) {\n		var current = $(this).jmpress("current"),\n			settings = $(this).jmpress("settings"),\n			stepData = $(this).jmpress("active").data("stepData"),\n			container = $(this).jmpress("container");\n		var zoomableSteps = stepData.viewPortZoomable || settings.viewPort.zoomable;\n		var halfWidth = $(container).innerWidth(),\n			halfHeight = $(container).innerHeight();\n		current.userTranslateX =\n			maxAbs(current.userTranslateX + x / current.zoomOriginWindowScale,\n			halfWidth * current.userZoom * current.userZoom / zoomableSteps);\n		current.userTranslateY =\n			maxAbs(current.userTranslateY + y / current.zoomOriginWindowScale,\n			halfHeight * current.userZoom * current.userZoom / zoomableSteps);\n		$(this).jmpress("reselect", "zoom");\n	});\n	$.jmpress(\'afterDeinit\', function( nil, eventData ) {\n		$(window).unbind(eventData.current.viewPortNamespace);\n	});\n	$.jmpress("setActive", function( step, eventData ) {\n		var viewPort = eventData.settings.viewPort;\n		var viewPortHeight = eventData.stepData.viewPortHeight || viewPort.height;\n		var viewPortWidth = eventData.stepData.viewPortWidth || viewPort.width;\n		var viewPortMaxScale = eventData.stepData.viewPortMaxScale || viewPort.maxScale;\n		var viewPortMinScale = eventData.stepData.viewPortMinScale || viewPort.minScale;\n		// Correct the scale based on the window\'s size\n		var windowScaleY = viewPortHeight && $(eventData.container).innerHeight()/viewPortHeight;\n		var windowScaleX = viewPortWidth && $(eventData.container).innerWidth()/viewPortWidth;\n		var windowScale = (windowScaleX || windowScaleY) && Math.min( windowScaleX || windowScaleY, windowScaleY || windowScaleX );\n\n		if(windowScale) {\n			windowScale = windowScale || 1;\n			if(viewPortMaxScale) {\n				windowScale = Math.min(windowScale, viewPortMaxScale);\n			}\n			if(viewPortMinScale) {\n				windowScale = Math.max(windowScale, viewPortMinScale);\n			}\n\n			var zoomableSteps = eventData.stepData.viewPortZoomable || eventData.settings.viewPort.zoomable;\n			if(zoomableSteps) {\n				var diff = (1/windowScale) - (1/viewPortMaxScale);\n				diff /= zoomableSteps;\n				windowScale = 1/((1/windowScale) - diff * eventData.current.userZoom);\n			}\n\n			eventData.target.transform.reverse();\n			if(eventData.current.userTranslateX && eventData.current.userTranslateY) {\n				eventData.target.transform.push(["translate", eventData.current.userTranslateX, eventData.current.userTranslateY, 0]);\n			} else {\n				eventData.target.transform.push(["translate"]);\n			}\n			eventData.target.transform.push(["scale",\n				windowScale,\n				windowScale,\n				1]);\n			eventData.target.transform.reverse();\n		}\n		eventData.current.zoomOriginWindowScale = windowScale;\n	});\n	$.jmpress("setInactive", function( step, eventData ) {\n		if(!eventData.nextStep || !step || $(eventData.nextStep).attr("id") !== $(step).attr("id")) {\n			eventData.current.userZoom = 0;\n			eventData.current.userTranslateX = 0;\n			eventData.current.userTranslateY = 0;\n		}\n	});\n\n}(jQuery, document, window));'},117:function(a,b,c){a.exports='/*!\n * ways.js\n * Control the flow of the steps\n */\n(function( $, document, window, undefined ) {\n\n	\'use strict\';\n	var $jmpress = $.jmpress;\n\n	/* FUNCTIONS */\n	function randomString() {\n		return "" + Math.round(Math.random() * 100000, 0);\n	}\n	// TODO allow call of route after init\n	function routeFunc( jmpress, route, type ) {\n		for(var i = 0; i < route.length - 1; i++) {\n			var from = route[i];\n			var to = route[i+1];\n			$(from, jmpress).attr(\'data-\' + type, to);\n		}\n	}\n	function selectPrevOrNext( step, eventData, attr, prev ) {\n		var stepData = eventData.stepData;\n		if(stepData[attr]) {\n			var near = $(step).near(stepData[attr], prev);\n			if(near && near.length) {\n				return near;\n			}\n			near = $(stepData[attr], this)[prev?"last":"first"]();\n			if(near && near.length) {\n				return near;\n			}\n		}\n	}\n\n	/* EXPORTED FUNCTIONS */\n	$jmpress( \'register\', \'route\', function( route, unidirectional, reversedRoute ) {\n		if( typeof route === "string" ) {\n			route = [route, route];\n		}\n		routeFunc(this, route, reversedRoute ? "prev" : "next");\n		if (!unidirectional) {\n			routeFunc(this, route.reverse(), reversedRoute ? "next" : "prev");\n		}\n	});\n\n	/* HOOKS */\n	$jmpress( \'initStep\', function( step, eventData ) {\n		for(var attr in {next:1,prev:1}) {\n			eventData.stepData[attr] = eventData.data[attr];\n		}\n	});\n	$jmpress( \'selectNext\', function( step, eventData ) {\n		return selectPrevOrNext.call(this, step, eventData, "next");\n	});\n	$jmpress( \'selectPrev\', function( step, eventData ) {\n		return selectPrevOrNext.call(this, step, eventData, "prev", true);\n	});\n\n}(jQuery, document, window));'},118:function(a,b,c){a.exports='/*!\n * jmpress.duration plugin\n * For auto advancing steps after a given duration and optionally displaying a\n * progress bar.\n */\n(function( $, document, window, undefined ) {\n	\'use strict\';\n\n	$.jmpress("defaults").duration = {\n		defaultValue: -1\n		,defaultAction: "next"\n		,barSelector: undefined\n		,barProperty: "width"\n		,barPropertyStart: "0"\n		,barPropertyEnd: "100%"\n	};\n	$.jmpress("initStep", function( step, eventData ) {\n		eventData.stepData.duration = eventData.data.duration && parseInt(eventData.data.duration, 10);\n		eventData.stepData.durationAction = eventData.data.durationAction;\n	});\n	$.jmpress("setInactive", function( step, eventData ) {\n		var settings = eventData.settings,\n			durationSettings = settings.duration,\n			current = eventData.current;\n		var dur = eventData.stepData.duration || durationSettings.defaultValue;\n		if( dur && dur > 0 ) {\n			if( durationSettings.barSelector ) {\n				var css = {\n					transitionProperty: durationSettings.barProperty\n					,transitionDuration: \'0\'\n					,transitionDelay: \'0\'\n					,transitionTimingFunction: \'linear\'\n				};\n				css[durationSettings.barProperty] = durationSettings.barPropertyStart;\n				var bars = $(durationSettings.barSelector);\n				$.jmpress("css", bars, css);\n				bars.each(function(idx, element) {\n					var next = $(element).next();\n					var parent = $(element).parent();\n					$(element).detach();\n					if(next.length) {\n						next.insertBefore(element);\n					} else {\n						parent.append(element);\n					}\n				});\n			}\n			if(current.durationTimeout) {\n				clearTimeout(current.durationTimeout);\n				current.durationTimeout = undefined;\n			}\n		}\n	});\n	$.jmpress("setActive", function( step, eventData ) {\n		var settings = eventData.settings,\n			durationSettings = settings.duration,\n			current = eventData.current;\n		var dur = eventData.stepData.duration || durationSettings.defaultValue;\n		if( dur && dur > 0 ) {\n			if( durationSettings.barSelector ) {\n				var css = {\n					transitionProperty: durationSettings.barProperty\n					,transitionDuration: (dur-settings.transitionDuration*2/3-100)+"ms"\n					,transitionDelay: (settings.transitionDuration*2/3)+\'ms\'\n					,transitionTimingFunction: \'linear\'\n				};\n				css[durationSettings.barProperty] = durationSettings.barPropertyEnd;\n				$.jmpress("css", $(durationSettings.barSelector), css);\n			}\n			var jmpress = this;\n			if(current.durationTimeout) {\n				clearTimeout(current.durationTimeout);\n				current.durationTimeout = undefined;\n			}\n			current.durationTimeout = setTimeout(function() {\n				var action = eventData.stepData.durationAction || durationSettings.defaultAction;\n				$(jmpress).jmpress(action);\n			}, dur);\n		}\n	});\n}(jQuery, document, window));\n'},119:function(a,b,c){a.exports='/*!\n * jmpress.presentation-mode plugin\n * Display a window for the presenter with notes and a control and view of the\n * presentation\n */\n(function( $, document, window, undefined ) {\n\n	\'use strict\';\n	var $jmpress = $.jmpress;\n\n	/* FUNCTIONS */\n	function randomString() {\n		return "" + Math.round(Math.random() * 100000, 0);\n	}\n\n	/* DEFAULTS */\n	$jmpress("defaults").presentationMode = {\n		use: true,\n		url: "presentation-screen.html",\n		notesUrl: false,\n		transferredValues: ["userZoom", "userTranslateX", "userTranslateY"]\n	};\n	$jmpress("defaults").keyboard.keys[80] = "presentationPopup"; // p key\n\n	/* HOOKS */\n	$jmpress("afterInit", function( nil, eventData) {\n		var current = eventData.current;\n\n		current.selectMessageListeners = [];\n\n		if(eventData.settings.presentationMode.use) {\n\n			window.addEventListener("message", function(event) {\n				// We do not test orgin, because we want to accept messages\n				// from all orgins\n				try {\n					var json = JSON.parse(event.data);\n					switch(json.type) {\n					case "select":\n						// TODO SECURITY filter targetId\n						$.each(eventData.settings.presentationMode.transferredValues, function(idx, name) {\n							eventData.current[name] = json[name];\n						});\n						$(eventData.jmpress).jmpress("select", {step: "#"+json.targetId, substep: json.substep}, json.reason);\n						break;\n					case "listen":\n						current.selectMessageListeners.push(event.source);\n						break;\n					case "ok":\n						clearTimeout(current.presentationPopupTimeout);\n						break;\n					case "read":\n						try {\n							event.source.postMessage(JSON.stringify({type: "url", url: window.location.href, notesUrl: eventData.settings.presentationMode.notesUrl}), "*");\n						} catch(e) {\n							$.error("Cannot post message to source: " + e);\n						}\n						break;\n					default:\n						throw "Unknown message type: " + json.type;\n					}\n				} catch(e) {\n					$.error("Recieved message is malformed: " + e);\n				}\n			});\n			try {\n				if(window.parent && window.parent !== window) {\n					window.parent.postMessage(JSON.stringify({\n						"type": "afterInit"\n					}), "*");\n				}\n			} catch(e) {\n				$.error("Cannot post message to parent: " + e);\n			}\n		}\n	});\n	$jmpress("afterDeinit", function( nil, eventData) {\n		if(eventData.settings.presentationMode.use) {\n			try {\n				if(window.parent && window.parent !== window) {\n					window.parent.postMessage(JSON.stringify({\n						"type": "afterDeinit"\n					}), "*");\n				}\n			} catch(e) {\n				$.error("Cannot post message to parent: " + e);\n			}\n		}\n	});\n	$jmpress("setActive", function( step, eventData) {\n		var stepId = $(eventData.delegatedFrom).attr("id"),\n			substep = eventData.substep,\n			reason = eventData.reason;\n		$.each(eventData.current.selectMessageListeners, function(idx, listener) {\n			try {\n				var msg = {\n					"type": "select",\n					"targetId": stepId,\n					"substep": substep,\n					"reason": reason\n				};\n				$.each(eventData.settings.presentationMode.transferredValues, function(idx, name) {\n					msg[name] = eventData.current[name];\n				});\n				listener.postMessage(JSON.stringify(msg), "*");\n			} catch(e) {\n				$.error("Cannot post message to listener: " + e);\n			}\n		});\n	});\n	$jmpress("register", "presentationPopup", function() {\n		function trySend() {\n			jmpress.jmpress("current").presentationPopupTimeout = setTimeout(trySend, 100);\n			try {\n				popup.postMessage(JSON.stringify({type: "url", url: window.location.href, notesUrl: jmpress.jmpress("settings").presentationMode.notesUrl}), "*");\n			} catch(e) {\n			}\n		}\n		var jmpress = $(this),\n			popup;\n		if(jmpress.jmpress("settings").presentationMode.use) {\n			popup = window.open($(this).jmpress("settings").presentationMode.url);\n			jmpress.jmpress("current").presentationPopupTimeout = setTimeout(trySend, 100);\n		}\n	});\n}(jQuery, document, window));\n'},120:function(a,b,c){a.exports='/*!\n * jmpress.secondary plugin\n * Apply a secondary animation when step is selected.\n */\n(function( $, document, window, undefined ) {\n	\'use strict\';\n	$.jmpress("initStep", function( step, eventData ) {\n		for(var name in eventData.data) {\n			if(name.indexOf("secondary") === 0) {\n				eventData.stepData[name] = eventData.data[name];\n			}\n		}\n	});\n	function exchangeIf(childStepData, condition, step) {\n		if(childStepData.secondary &&\n			childStepData.secondary.split(" ").indexOf(condition) !== -1) {\n			for(var name in childStepData) {\n				if(name.length > 9 && name.indexOf("secondary") === 0) {\n					var tmp = childStepData[name];\n					var normal = name.substr(9);\n					normal = normal.substr(0, 1).toLowerCase() + normal.substr(1);\n					childStepData[name] = childStepData[normal];\n					childStepData[normal] = tmp;\n				}\n			}\n			$(this).jmpress("reapply", $(step));\n		}\n	}\n	$.jmpress("beforeActive", function( step, eventData ) {\n		exchangeIf.call(eventData.jmpress, $(step).data("stepData"), "self", step);\n		var parent = $(step).parent();\n		$(parent)\n			.children(eventData.settings.stepSelector)\n			.each(function(idx, child) {\n				var childStepData = $(child).data("stepData");\n				exchangeIf.call(eventData.jmpress, childStepData, "siblings", child);\n			});\n		function grandchildrenFunc(idx, child) {\n			var childStepData = $(child).data("stepData");\n			exchangeIf.call(eventData.jmpress, childStepData, "grandchildren", child);\n		}\n		for(var i = 1; i < eventData.parents.length; i++) {\n			$(eventData.parents[i])\n				.children(eventData.settings.stepSelector)\n				.each();\n		}\n	});\n	$.jmpress("setInactive", function( step, eventData ) {\n		exchangeIf.call(eventData.jmpress, $(step).data("stepData"), "self", step);\n		var parent = $(step).parent();\n		$(parent)\n			.children(eventData.settings.stepSelector)\n			.each(function(idx, child) {\n				var childStepData = $(child).data("stepData");\n				exchangeIf.call(eventData.jmpress, childStepData, "siblings", child);\n			});\n		function grandchildrenFunc(idx, child) {\n			var childStepData = $(child).data("stepData");\n			exchangeIf.call(eventData.jmpress, childStepData, "grandchildren", child);\n		}\n		for(var i = 1; i < eventData.parents.length; i++) {\n			$(eventData.parents[i])\n				.children(eventData.settings.stepSelector)\n				.each(grandchildrenFunc);\n		}\n	});\n}(jQuery, document, window));\n'},121:function(a,b,c){a.exports='/*!\n * jmpress.toggle plugin\n * For binding a key to toggle de/initialization of jmpress.js.\n */\n(function( $, document, window, undefined ) {\n	\'use strict\';\n	$.jmpress("register", "toggle", function( key, config, initial ) {\n		var jmpress = this;\n		$(document).bind("keydown", function( event ) {\n			if ( event.keyCode === key ) {\n				if ($(jmpress).jmpress("initialized")) {\n					$(jmpress).jmpress("deinit");\n				} else {\n					$(jmpress).jmpress(config);\n				}\n			}\n		});\n		if ( initial ) {\n			$(jmpress).jmpress(config);\n		}\n	});\n}(jQuery, document, window));\n'}})